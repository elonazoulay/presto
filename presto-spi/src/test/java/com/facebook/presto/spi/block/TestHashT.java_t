/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.facebook.presto.spi.block;

import com.facebook.presto.spi.Page;
import com.facebook.presto.spi.block.BlockContents;
import com.facebook.presto.spi.block.LongArrayBlockBuilder;
//import com.facebook.presto.spi.type.BigintType;
//import com.facebook.presto.spi.type.DoubleType;
//import static org.testng.Assert.assertEquals;
import io.airlift.slice.Slice;
import io.airlift.slice.Slices;
import java.util.Arrays;
import static java.lang.Double.doubleToLongBits;
import static java.lang.Double.longBitsToDouble;
import static java.lang.System.arraycopy;
import java.lang.reflect.Field;
import static java.lang.Integer.numberOfTrailingZeros;
import static java.lang.Long.numberOfTrailingZeros;

import sun.misc.Unsafe;

#define MHASH_M  0xc6a4a7935bd1e995L
#define MHASH_R 47

    #define MHASH_STEP_1(h, data) \
{ \
  long __k = data; \
      __k *= MHASH_M;  \
      __k ^= __k >> MHASH_R;  \
      h = __k * MHASH_M; \
    }

    #define MHASH_STEP(h, data) \
{ \
  long __k = data; \
      __k *= MHASH_M;  \
      __k ^= __k >> MHASH_R;  \
      __k *= MHASH_M;  \
      h ^= __k; \
      h *= MHASH_M; \
    }



    #define SLABSIZE (128 * 1024)
#define SLABSHIFT 17
    #define SLABMASK 0x1ffff

    #ifdef SLICES

	#define DECLTABLE(table) \
  int statusMask = table.statusMask; \
Slice[] slices = table.slices;
  
	
#define DECLGET(prefix) Slice prefix##slice; int prefix##offset 

    #define  PREGET(prefix, l)					\
{ prefix##slice = slices[(int)((l) >> SLABSHIFT)]; prefix##offset = (int)(l) & SLABMASK; }

#define GETL(prefix, field)			\
    prefix##slice.getLong(prefix##offset + field)

    #define SETL(prefix, field, v)			\
    prefix##slice.setLong(prefix##offset + field, v)

    #define SLICEPARAM(prefix) \
    Slice prefix##slice, int prefix##offset
    
#define SLICEARG(prefix) prefix##slice, prefix##offset

#define SLICEREF(s, o) \
						 (((s) << SLABSHIFT) + (o))
    #else
						 
	#define DECLGET(prefix) long prefix##ptr
	    #define PREGET(prefix, l)		\
	  prefix##ptr = l
						 #define GETL(prefix, field) \
    unsafe.getLong(prefix##ptr, field)

						 #define SETL(prefix, field, v) \
    unsafe.setLong(prefix##ptr, field, v)
   
    
#endif


class TestHash {


      static Unsafe unsafe;

      static {
	  try {
	      // fetch theUnsafe object
	      Field field = Unsafe.class.getDeclaredField("theUnsafe");
	      field.setAccessible(true);
	      unsafe = (Unsafe) field.get(null);
	      if (unsafe == null) {
		  throw new RuntimeException("Unsafe access not available");
	      }
	  }
	  catch (Exception e) {
	      throw new RuntimeException(e);
	  }
      }


    // Generic hash table 
    class HashTable
    		{
	int mask;
	int statusMask;
	long[] bloom;
	long[] status;
	long[] table;
	Slice[] slices = new Slice[16];
	long[] slabs;
	int[] fill = new int[16];
	int currentSlab = -1;
	
	long nextResult(long entry, int offset)
	{
	    DECLGET(a);
	    PREGET(a, entry);
	    return GETL(a, offset);
	}

	// Allocates 'bytes' of contiguous space for hash table payload.
	// Returns a slice index, offset pair or a raw long.
	public long allocBytes(int bytes)
	{
	    if (currentSlab == -1 || fill[currentSlab] + bytes > SLABSIZE) {
		long w = newSlab();
		fill[currentSlab] = bytes;
		return w;
	    }
	    int off = fill[currentSlab];
	    fill[currentSlab] += bytes;
	    return SLICEREF(currentSlab, off);
	}

	long newSlab() {
	    #ifdef SLICES
		++currentSlab;
		if (slices.length <= currentSlab) {
		    int newSize = slices.length * 2;
		    slices = Arrays.copyOf(slices, newSize);
		    fill = Arrays.copyOf(fill, newSize);
		}
		Slice s = Slices.allocate(SLABSIZE);
	    slices[currentSlab] = s;
	    return SLICEREF(currentSlab, 0);
#else
    #endif
	}
	
	void setSize(int count) {
	    count *= 1.3;
	    int size = 1024;
	    while (size < count) {
		size *= 2;
	    }
	    mask = size - 1;
	    table = new long[size];
	    status = new long[size / 8];
	    statusMask = mask >> 3;
	    for (int i = 0; i <= statusMask; ++i) {
		status[i] = -1;
	    }
	}
    }
	
    // Generated class for a key/dependent layout 
    class HashBuild extends ExprContext
    {
	HashTable table = new HashTable();
	BlockContents k1 = new BlockContents();
	BlockContents k2 = new BlockContents();
	BlockContents d1 = new BlockContents();
		int entryCount = 0;
	
	long hashRow(long row)
	{
	    DECLTABLE(table);
	    DECLGET(k);
	    PREGET(k, row);
	    long h;
	    MHASH_STEP_1(h, GETL(k, 0));
	    MHASH_STEP(h, GETL(k, 8));
	    return h;
	}
	
	void addImput(Page page)
	{
	    k1.decodeBlock(page.getBlock(0), mapHolder);
	    k2.decodeBlock(page.getBlock(1), mapHolder);
	    d1.decodeBlock(page.getBlock(2), mapHolder);
	    int positionCount = page.getPositionCount();
	    nullsInBatch = null;
	    int[] k1Map = k1.rowNumberMap;
	    int[] k2Map = k2.rowNumberMap;
	    int[]d1Map = d1.rowNumberMap;
	    addNullFlags(k1.valueIsNull, k1.isIdentityMap ? null : k1Map, positionCount);
	    addNullFlags(k2.valueIsNull, k2.isIdentityMap ? null : k2Map, positionCount);


	    DECLTABLE(table);

	    for (int i = 0; i < positionCount; ++i) {
		if (nullsInBatch == null ||  !nullsInBatch[i]) {
		    ++entryCount;
		    long row = table.allocBytes(32);
		    DECLGET(k);
		    PREGET(k, row);
		    SETL(k,0, k1.longs[k1Map[i]]);
		    SETL(k, 8, k2.longs[k1Map[i]]);
		    SETL(k, 16, d1.longs[d1Map[i]]);
		    SETL(k, 24, -1);
		}
	    }
	    k1.release(mapHolder);
	    k2.release(mapHolder);
	    d1.release(mapHolder);
	}
	void build()
	{
	    DECLTABLE(table);
	    table.setSize(entryCount);
	    int batch = 1024;
	    long[] hashes = new long[batch];
	    long[] entries = new long[batch];
	    int fill = 0;
	    for (int slab = 0; slab <= table.currentSlab; ++slab) {
		int slabFill = table.fill[slab];
		for (int offset = 0; offset < slabFill; offset += 32) {
		    long entry = SLICEREF(slab, offset);
		    entries[fill] = entry;
		    hashes[fill++] = hashRow(entry);
		    if (fill == batch) {
			insertHashes(hashes, entries, fill);
			    fill = 0;
		    }
		}
	    }
	    insertHashes(hashes, entries, fill);
	}

	void insertHashes(long[] hashes, long[] entries, int fill)
	{
	    DECLTABLE(table);
	    for (int i = 0; i < fill; ++i) {
		int h = (int)hashes[i] & statusMask;
	    boolean inserted = false;
	    long field = (hashes[i] >> 56) & 0x7f;
	    byte statusByte = (byte)field;
	    field |= field << 8;
	    field |= field << 16;
	    field |= field << 32;
	    do {
		long st = table.status[h];
		long hits = st ^ field;
		hits -= 0x7f7f7f7f7f7f7f7fL;
		hits &= 0x8080808080808080L;
		DECLGET(a);
		DECLGET(b);
		while (hits != 0) {
			PREGET(b, entries[i]);
			       int pos = Long.numberOfTrailingZeros(hits) >> 3;
			       PREGET(a, table.table[h * 8 + pos]);
			       if (GETL(a, 0) == GETL(b, 0) && GETL(a, 8) == GETL(b, 8)) {
				   SETL(a, 24, entries[i]);
				   inserted = true;
				   break;
			       }
			       hits = hits &= (hits - 1);
		    }
		if (hits == 0) {
		// No matches in the status group, see if can insert.
		st &= 0x8080808080808080L;
		if (st != 0) {
		    int pos = Long.numberOfTrailingZeros(st) >> 3;
		    table.status[h] ^= ((~statusByte) & 0xff) << (pos * 8);
		    table.table[h * 8 + pos] = entries[i];
		    break;
		}
	    }
	    h = (h + 1) & statusMask;
	    } while (!inserted);
	    }
	}
    }
	
    class HashProbe extends ExprContext {
	BlockContents k1 = new BlockContents();
	BlockContents k2 = new BlockContents();
	long hashes[];
	HashTable table;
	int currentInput;
	long nextRow;
	long[] k1d;
	long[] k2d;
	int[] k1Map;
	int[] k2Map;
	int maxResults = 1024;
	int[] candidates;
	int candidateFill;
	int positionCount;
	int[] resultMap;
	int resultFill;
	long[] result1;
	long currentResult;
	int currentProbe;
	Page resultPage;
	
	public void addInput(Page page) {
	    k1.decodeBlock(page.getBlock(0), mapHolder);
	    k2.decodeBlock(page.getBlock(0), mapHolder);
	    positionCount = page.getPositionCount();
	    nullsInBatch = null;
	    k1Map = k1.rowNumberMap;
	    k2Map = k2.rowNumberMap;
	    addNullFlags(k1.valueIsNull, k1.isIdentityMap ? null : k1Map, positionCount);
	    addNullFlags(k2.valueIsNull, k2.isIdentityMap ? null : k2Map, positionCount);
	    DECLTABLE(table);
	    if (candidates == null || candidates.length < positionCount) {
		candidates = mapHolder.getIntArray(positionCount);
	    }
	    if (nullsInBatch != null) {
		for (int i = 0; i < positionCount; ++i) {
		    if (nullsInBatch[i]) {
			candidates[candidateFill++] = i;
		    }
		}
	    } else {
		for (int i = 0; i < positionCount; ++i) {
		    candidates[i] = i;
		    candidateFill = positionCount;
		}
	    }
	    for (int i = 0; i <candidateFill; ++i) {
		int row = candidates[i];
		long h;
		MHASH_STEP_1(h, k1d[k1Map[row]]);
		MHASH_STEP(h, k2d[k2Map[row]]);
		hashes[row] = h;
	    }
	    currentProbe = 0;
	    currentResult = -1;
	}


	public boolean addResult(long entry, int candidate)
	{
	    int probeRow = candidates[candidate];
	    DECLTABLE(table);
	    do {
		resultMap[resultFill] = probeRow;
		DECLGET(a);
		PREGET(a, entry);
		result1[resultFill] = GETL(a, 16);
		entry = GETL(a, 24);
		++resultFill;
		if (resultFill >= maxResults) {
		    currentResult = entry;
		    currentProbe = candidate;
		    finishResult();
		    return true;
		}
	    } while (entry != -1);
	    currentResult = -1;
	    return false;
	}

	void finishResult()
	{
	    k1.release(mapHolder);
	    k2.release(mapHolder);
	    if (resultFill == 0) {
		resultPage = null;
		return;
	    }
	    resultPage = new Page(
				  new LongArrayBlock(resultFill, null, result1));
	    resultFill = 0;
	}

		#define DECLPROBE(sub)		\
		    long entry##sub = -1; \
		    long field##sub;		\
	    long hits##sub; \
	    int hash##sub; \
	    int row##sub; \
	    	int pos##sub; \
	    boolean match##sub = false;


	    #define PREPROBE(sub) \
		row##sub = candidates[currentProbe + sub]; \
	hash##sub = (int)hashes[row##sub];	   \
	    field##sub = (hash##sub >> 56) & 0x7f; \
	    hash##sub &= statusMask; \
	    hits##sub = table.status[hash##sub]; \
	    field##sub |= field##sub << 8; \
	    field##sub |= field##sub << 16; \
	    field##sub |= field##sub << 32; \
	DECLGET(g##sub);
	


	#define FIRSTPROBE(sub)	      \
	    hits##sub ^= field##sub;  \
	hits##sub -= 0x0101010101010101L; \
	hits##sub &= 0x8080808080808080L; \
	if (hits##sub != 0) { \
	    pos##sub = Long.numberOfTrailingZeros(hits##sub) >> 3; \
	    hits##sub &= hits##sub - 1; \
	    entry##sub = table.table[hash##sub * 8 + pos##sub]; \
	    PREGET(g##sub, entry##sub); \
	    match##sub =GETL(g##sub, 0) == k1d[k1Map[row##sub]] \
		& GETL(g##sub, 8) == k2d[k2Map[row##sub]]; \
	}
	
	    
	    #define FULLPROBE(sub) \
    if (match##sub) { \
	if (addResult(entry##sub, currentProbe + sub)) return; \
    } \
    else { \
	bucketLoop##sub: \
	for (;;) {		 \
	while (hits##sub != 0) { \
	    pos##sub = Long.numberOfTrailingZeros(hits##sub) >> 3; \
	    entry##sub = table.table[hash##sub * 8 + pos##sub]; \
	    PREGET(g##sub, entry##sub); \
	    if (GETL(g##sub, 0) == k1d[k1Map[row##sub]] && GETL(g##sub, 8) == k2d[k2Map[row##sub]]) { \
		if (addResult(entry##sub, currentProbe + sub)) { \
		    return; \
		} \
		break bucketLoop##sub;		\
	    } \
	    hits##sub &= hits##sub - 1; \
	} \
	if ((table.status[hash##sub] & 0x8080808080808080L) != 0) break; \
	hash##sub = (hash##sub + 1) & statusMask;	\
	hits##sub = table.status[hash##sub]; \
	hits##sub ^= field##sub; \
	hits##sub -= 0x0101010101010101L; \
	hits##sub &= 0x8080808080808080L; \
    }			  \
}      

	
	public void getOutput()
	{
	    DECLTABLE(table);
	    if (currentResult != -1) {
		if (addResult(currentResult, currentProbe)) {
		    return;
		}
	    }
	    for (;currentProbe < candidateFill; ++currentProbe) {
		DECLPROBE(0);
		PREPROBE(0);
		FIRSTPROBE(0);
		FULLPROBE(0);
	    }
	    finishResult();
	}


    }
    
    
}
